<html>
<head>
  <title></title>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <style type="text/css">
 .lst-kix_jhfaeamzsz1h-8>li:before{content:"\0025a0  "}.lst-kix_jhfaeamzsz1h-7>li:before{content:"\0025cb  "}.lst-kix_jhfaeamzsz1h-6>li:before{content:"\0025cf  "}.lst-kix_jhfaeamzsz1h-0>li:before{content:"\0025cf  "}.lst-kix_o6hg8xfa70sv-2>li:before{content:"\0025a0  "}.lst-kix_jhfaeamzsz1h-1>li:before{content:"\0025cb  "}.lst-kix_jhfaeamzsz1h-2>li:before{content:"\0025a0  "}.lst-kix_o6hg8xfa70sv-0>li:before{content:"\0025cf  "}.lst-kix_o6hg8xfa70sv-1>li:before{content:"\0025cb  "}.lst-kix_e1qk995u8hc6-6>li:before{content:"\0025cf  "}.lst-kix_e1qk995u8hc6-5>li:before{content:"\0025a0  "}.lst-kix_jhfaeamzsz1h-4>li:before{content:"\0025cb  "}.lst-kix_jhfaeamzsz1h-3>li:before{content:"\0025cf  "}.lst-kix_jhfaeamzsz1h-5>li:before{content:"\0025a0  "}.lst-kix_e1qk995u8hc6-3>li:before{content:"\0025cf  "}.lst-kix_e1qk995u8hc6-4>li:before{content:"\0025cb  "}.lst-kix_pvsa2umjq4yn-7>li:before{content:"\0025cb  "}.lst-kix_pvsa2umjq4yn-6>li:before{content:"\0025cf  "}.lst-kix_pvsa2umjq4yn-8>li:before{content:"\0025a0  "}.lst-kix_o6hg8xfa70sv-8>li:before{content:"\0025a0  "}.lst-kix_e1qk995u8hc6-7>li:before{content:"\0025cb  "}.lst-kix_e1qk995u8hc6-8>li:before{content:"\0025a0  "}.lst-kix_o6hg8xfa70sv-3>li:before{content:"\0025cf  "}.lst-kix_o6hg8xfa70sv-4>li:before{content:"\0025cb  "}.lst-kix_o6hg8xfa70sv-5>li:before{content:"\0025a0  "}.lst-kix_o6hg8xfa70sv-6>li:before{content:"\0025cf  "}.lst-kix_o6hg8xfa70sv-7>li:before{content:"\0025cb  "}ul.lst-kix_o6hg8xfa70sv-7{list-style-type:none}ul.lst-kix_o6hg8xfa70sv-6{list-style-type:none}ul.lst-kix_o6hg8xfa70sv-5{list-style-type:none}ul.lst-kix_o6hg8xfa70sv-4{list-style-type:none}ul.lst-kix_pvsa2umjq4yn-8{list-style-type:none}ul.lst-kix_pvsa2umjq4yn-7{list-style-type:none}ul.lst-kix_pvsa2umjq4yn-6{list-style-type:none}ul.lst-kix_pvsa2umjq4yn-5{list-style-type:none}ul.lst-kix_o6hg8xfa70sv-8{list-style-type:none}ul.lst-kix_pvsa2umjq4yn-4{list-style-type:none}ul.lst-kix_pvsa2umjq4yn-3{list-style-type:none}ul.lst-kix_pvsa2umjq4yn-2{list-style-type:none}ul.lst-kix_pvsa2umjq4yn-1{list-style-type:none}ul.lst-kix_pvsa2umjq4yn-0{list-style-type:none}.lst-kix_pvsa2umjq4yn-4>li:before{content:"\0025cb  "}.lst-kix_pvsa2umjq4yn-5>li:before{content:"\0025a0  "}.lst-kix_dtr089qt3fpp-8>li:before{content:"\0025a0  "}.lst-kix_dtr089qt3fpp-7>li:before{content:"\0025cb  "}.lst-kix_pvsa2umjq4yn-3>li:before{content:"\0025cf  "}.lst-kix_dtr089qt3fpp-4>li:before{content:"\0025cb  "}.lst-kix_dtr089qt3fpp-5>li:before{content:"\0025a0  "}ul.lst-kix_e1qk995u8hc6-8{list-style-type:none}.lst-kix_pvsa2umjq4yn-2>li:before{content:"\0025a0  "}.lst-kix_pvsa2umjq4yn-1>li:before{content:"\0025cb  "}.lst-kix_dtr089qt3fpp-6>li:before{content:"\0025cf  "}ul.lst-kix_e1qk995u8hc6-2{list-style-type:none}ul.lst-kix_e1qk995u8hc6-3{list-style-type:none}.lst-kix_dtr089qt3fpp-0>li:before{content:"\0025cf  "}.lst-kix_dtr089qt3fpp-1>li:before{content:"\0025cb  "}ul.lst-kix_e1qk995u8hc6-0{list-style-type:none}.lst-kix_pvsa2umjq4yn-0>li:before{content:"\0025cf  "}ul.lst-kix_e1qk995u8hc6-1{list-style-type:none}ul.lst-kix_e1qk995u8hc6-6{list-style-type:none}ul.lst-kix_e1qk995u8hc6-7{list-style-type:none}.lst-kix_dtr089qt3fpp-3>li:before{content:"\0025cf  "}ul.lst-kix_e1qk995u8hc6-4{list-style-type:none}ul.lst-kix_e1qk995u8hc6-5{list-style-type:none}.lst-kix_dtr089qt3fpp-2>li:before{content:"\0025a0  "}ul.lst-kix_jhfaeamzsz1h-0{list-style-type:none}ul.lst-kix_jhfaeamzsz1h-5{list-style-type:none}ul.lst-kix_jhfaeamzsz1h-6{list-style-type:none}ul.lst-kix_jhfaeamzsz1h-7{list-style-type:none}ul.lst-kix_jhfaeamzsz1h-8{list-style-type:none}ul.lst-kix_jhfaeamzsz1h-1{list-style-type:none}ul.lst-kix_jhfaeamzsz1h-2{list-style-type:none}ul.lst-kix_jhfaeamzsz1h-3{list-style-type:none}ul.lst-kix_jhfaeamzsz1h-4{list-style-type:none}ul.lst-kix_dtr089qt3fpp-8{list-style-type:none}ul.lst-kix_dtr089qt3fpp-5{list-style-type:none}ul.lst-kix_o6hg8xfa70sv-3{list-style-type:none}ul.lst-kix_dtr089qt3fpp-4{list-style-type:none}ul.lst-kix_o6hg8xfa70sv-2{list-style-type:none}ul.lst-kix_dtr089qt3fpp-7{list-style-type:none}ul.lst-kix_o6hg8xfa70sv-1{list-style-type:none}ul.lst-kix_dtr089qt3fpp-6{list-style-type:none}ul.lst-kix_o6hg8xfa70sv-0{list-style-type:none}ul.lst-kix_dtr089qt3fpp-1{list-style-type:none}ul.lst-kix_dtr089qt3fpp-0{list-style-type:none}ul.lst-kix_dtr089qt3fpp-3{list-style-type:none}ul.lst-kix_dtr089qt3fpp-2{list-style-type:none}ul.lst-kix_ym0w6xgs98yu-3{list-style-type:none}ul.lst-kix_ym0w6xgs98yu-4{list-style-type:none}ul.lst-kix_ym0w6xgs98yu-1{list-style-type:none}ul.lst-kix_ym0w6xgs98yu-2{list-style-type:none}ul.lst-kix_ym0w6xgs98yu-0{list-style-type:none}ul.lst-kix_ym0w6xgs98yu-7{list-style-type:none}ul.lst-kix_ym0w6xgs98yu-8{list-style-type:none}ul.lst-kix_ym0w6xgs98yu-5{list-style-type:none}ul.lst-kix_ym0w6xgs98yu-6{list-style-type:none}.lst-kix_ym0w6xgs98yu-8>li:before{content:"\0025a0  "}.lst-kix_ym0w6xgs98yu-7>li:before{content:"\0025cb  "}.lst-kix_e1qk995u8hc6-1>li:before{content:"\0025cb  "}.lst-kix_ym0w6xgs98yu-4>li:before{content:"\0025cb  "}.lst-kix_ym0w6xgs98yu-3>li:before{content:"\0025cf  "}.lst-kix_ym0w6xgs98yu-5>li:before{content:"\0025a0  "}.lst-kix_ym0w6xgs98yu-2>li:before{content:"\0025a0  "}.lst-kix_ym0w6xgs98yu-6>li:before{content:"\0025cf  "}.lst-kix_e1qk995u8hc6-2>li:before{content:"\0025a0  "}.lst-kix_e1qk995u8hc6-0>li:before{content:"\0025cf  "}.lst-kix_ym0w6xgs98yu-0>li:before{content:"\0025cf  "}.lst-kix_ym0w6xgs98yu-1>li:before{content:"\0025cb  "}ol{margin:0;padding:0}.c15{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c0{orphans:2;widows:2;direction:ltr}.c9{padding-top:12pt;padding-bottom:2pt}.c10{padding:0;margin:0}.c8{font-size:11pt;color:#000000}.c19{padding-top:24pt}.c7{height:11pt}.c5{font-weight:bold}.c11{color:#ff0000}.c2{margin-left:36pt}.c16{text-decoration:underline}.c13{margin-left:144pt}.c12{color:#00ff00}.c20{font-size:23pt}.c4{padding-left:0pt}.c1{font-family:"Courier New"}.c6{padding-bottom:4pt}.c14{font-size:17pt}.c17{margin-left:72pt}.c18{text-indent:36pt}.c3{font-style:italic}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style>
</head>

<body class="c15">
<h1 class="c0 c19"><a name="h.xh71mwtfvowb"></a><span class="c5 c20">Esame di
Tecniche di Programmazione del 11/09/2015</span></h1>

<h4 class="c0 c9"><a name="h.q0qdde2sajm3"></a><span class="c8 c5">Istruzioni
per lo svolgimento della prova:</span></h4>
<ul class="c10 lst-kix_pvsa2umjq4yn-0 start">
  <li class="c0 c2 c4"><span>Inserire nel file studente.txt i dati personali
    richiesti (</span><span class="c5">matricola, nome e cognome</span><span>)
    senza toccare altre parti del file, quindi salvare e chiudere il
    file.</span></li>
  <li class="c0 c2 c4"><span>All’esercizio i è associata la directory
    esercizio{i}, contenente i file necessari allo svolgimento
    dell’esercizio. Ciascun esercizio deve essere svolto modificando
    esclusivamente il file esercizio{i}.h (se necessario) ed esercizio{i}.c
    presenti nella directory corrispondente. Nessun file per nessun motivo deve
    essere spostato dalla directory in cui si trova. Nessun altro file deve
    essere modificato. Non devono essere creati ulteriori file.</span></li>
  <li class="c0 c2 c4"><span>Il file contenente il programma principale di
    ciascun esercizio è test_esercizio{i}.c. Tale file deve essere compilato
    usando il Makefile fornito nella directory, ed il corrispondente eseguibile
    (test_esercizio{i}) lanciato per eseguire i test di correttezza e
    conoscerne l’esito. Il file test_esercizio{i}.c non deve essere
    modificato.</span></li>
  <li class="c0 c2 c4"><span>Alla fine del tempo concesso per svolgere l' esame
    o, se lo avete terminato prima dello scadere del tempo, dovete eseguire lo
    </span><span class="c5">script di consegna dell' esame</span><span>. La
    consegna può essere effettuata </span><span class="c5">una ed una volta
    sola</span><span>, per cui consegnate solo quando siete sicuri di volerlo
    fare. Lo script è fornito insieme alla documentazione dell' esame e per
    eseguirlo basterà andare tramite terminale nella cartella dove si trova lo
    script consegna_esame.sh e avviarlo da linea di comando. Il comando da
    lanciare risulterà simile al seguente: </span><span class="c1">"bash
    ./consegna_esame.sh"</span><span>. </span><span class="c5">Lo script di
    consegna deve essere eseguito dalla directory in cui esso si trova, in caso
    contrario ritornerà un errore</span><span>. Una volta avviato lo script
    controllate che la consegna sia andata a buon fine </span><span
    class="c5">verificando</span><span> che sul terminale venga stampato un
    output simile al seguente:</span></li>
  <li class="c0 c2 c4"><span class="c1">local:
    matricola_cognome_nome_hostname.tar.gz remote:
    uploads/matricola_cognome_nome_hostname.tar.gz</span></li>
  <li class="c0 c2 c4"><span class="c1">200 PORT command successful. Consider
    using PASV.</span></li>
  <li class="c0 c2 c4"><span class="c1">150 Ok to send data.</span></li>
  <li class="c0 c2 c4"><span class="c1">226 Transfer complete.</span></li>
  <li class="c0 c2 c4"><span class="c1">4886 bytes sent in 0.00 secs (113606.8
    kB/s)</span></li>
  <li class="c0 c2 c4"><span class="c1">221 Goodbye.</span></li>
  <li class="c0 c2 c4"><span>Verranno corretti esclusivamente gli esercizi la
    cui compilazione dia esito positivo. In caso contrario verrà assegnato un
    punteggio nullo. Se non verrà eseguito lo script di consegna dell' esame
    esso non verrà corretto (è equivalente a non aver consegnato il compito a
    fine esame).</span></li>
  <li class="c0 c2 c4"><span>Per eventuali problemi o dubbi, chiedere al
    docente.</span></li>
</ul>

<h2 class="c0 c6"><a name="h.c3y3leacb8af"></a><span class="c5 c14">Esercizio
1</span></h2>

<p class="c0"><span>Sia data la seguente struttura Mat</span></p>

<p class="c0"><span class="c1">typedef struct Mat {</span></p>

<p class="c0"><span class="c1">  int rows; // numero di righe</span></p>

<p class="c0"><span class="c1">  int cols; // numero di colonne</span></p>

<p class="c0"><span class="c1">  int** row_ptrs; // puntatori alle
righe</span></p>

<p class="c0"><span class="c1">} Mat;</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span>Implementare la seguente funzione C:</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span class="c1">int matrixBlockCopy(Mat* dest, Mat* src,
</span></p>

<p class="c0 c13"><span class="c1">    int start_row, int
start_col);</span></p>

<p class="c0"><span>che dati in input</span></p>
<ul class="c10 lst-kix_jhfaeamzsz1h-0 start">
  <li class="c0 c2 c4"><span>puntatore ad una matrice </span><span
    class="c1">dest</span></li>
  <li class="c0 c2 c4"><span>puntatore ad una matrice </span><span
    class="c1 c3">src</span></li>
  <li class="c0 c2 c4"><span>un intero che specifica il numero di riga
    </span><span class="c1">start_row</span></li>
  <li class="c0 c2 c4"><span>un intero che specifica il numero di colonna
    </span><span class="c1">start_col</span></li>
</ul>

<p class="c0"><span>sostituisca gli elementi di </span><span
class="c3">dest</span><span> con quelli di </span><span
class="c1">src</span><span>, nel sottoblocco di dimensione </span></p>

<p class="c0"><span class="c1">src-&gt;rows</span><span> x </span><span
class="c1">src-&gt;cols</span><span> che inizia dalla riga </span><span
class="c1">start_row</span><span> dalla colonna </span><span
class="c1">start_col</span><span>.</span></p>

<p class="c0"><span>Se l'operazione non e' possibile perche' il blocco copiato
eccede i limiti della matrice di destinazione, la funzione ritorna 0. In caso
contrario la funzione ritorna il numero di elementi copiati (ovvero il numero
di elementi di </span><span class="c1">src</span><span>).</span></p>

<h4 class="c0 c9"><a name="h.uv197rftuw80"></a><span
class="c8 c5">Esempio</span></h4>

<p class="c0"><span>Data una struttura Mat </span><span
class="c1">dest</span><span> contenente la seguente immagine 8x8:</span></p>

<p class="c0"><span class="c1">1 2 3 1 3 3 2 1</span></p>

<p class="c0"><span class="c1">2 3 1 3 3 2 1 0</span></p>

<p class="c0"><span class="c1">1 3 3 2 1 2 1 1</span></p>

<p class="c0"><span class="c1">1 2 3 1 3 3 2 1</span></p>

<p class="c0"><span class="c1">1 3 3 2 1 2 1 1</span></p>

<p class="c0"><span class="c1">2 3 1 2 2 1 2 1</span></p>

<p class="c0"><span class="c1">1 2 3 1 3 3 2 1</span></p>

<p class="c0"><span class="c1">2 3 1 3 3 2 1 0</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span>Data una struttura Mat</span><span
class="c1"> src</span><span> contenente la seguente matrice 3x3:</span></p>

<p class="c0"><span class="c1">5 9 7</span></p>

<p class="c0"><span class="c1">9 9 9</span></p>

<p class="c0"><span class="c1">8 9 6</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span>richiamando la seguente linea di codice:</span></p>

<p class="c0 c7"><span></span></p>

<p class="c0"><span class="c1">matrixBlockCopy(dest, src, 2, 2);</span></p>

<p class="c0 c7"><span></span></p>

<p class="c0"><span>si ottiene il seguente effetto su src:</span></p>

<p class="c0"><span class="c1">1 2 3 1 3 3 2 1</span></p>

<p class="c0"><span class="c1">2 3 1 3 3 2 1 0</span></p>

<p class="c0"><span class="c1">1 3 </span><span class="c5 c12 c1">5 9
7</span><span class="c1"> 2 1 1</span></p>

<p class="c0"><span class="c1">1 2 </span><span class="c5 c12 c1">9 9
9</span><span class="c1"> 3 2 1</span></p>

<p class="c0"><span class="c1">1 3 </span><span class="c5 c12 c1">8 9
6</span><span class="c12 c1"> </span><span class="c1">2 1 1</span></p>

<p class="c0"><span class="c1">2 3 1 2 2 1 2 1</span></p>

<p class="c0"><span class="c1">1 2 3 1 3 3 2 1</span></p>

<p class="c0"><span class="c1">2 3 1 3 3 2 1 0</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span>e la funzione ritorna 9.</span></p>

<p class="c0 c7"><span></span></p>

<p class="c0"><span>Invocando invece:</span></p>

<p class="c0 c7"><span></span></p>

<p class="c0"><span class="c1">matrixBlockCopy(dest, src, 6, 6);</span></p>

<p class="c0 c7"><span></span></p>

<p class="c0"><span class="c3">src</span><span> rimane immutata, e la funzione
ritorna 0. L'operazione di copia infatti eccederebbe i limiti della
matrice.</span></p>

<p class="c0 c7"><span></span></p>

<p class="c0"><span class="c1">1 2 3 1 3 3 2 1</span></p>

<p class="c0"><span class="c1">2 3 1 3 3 2 1 0</span></p>

<p class="c0"><span class="c1">1 3 3 2 1 2 1 1</span></p>

<p class="c0"><span class="c1">1 2 3 1 3 3 2 1</span></p>

<p class="c0"><span class="c1">1 3 3 2 1 2 1 1</span></p>

<p class="c0"><span class="c1">2 3 1 2 2 1 2 1</span></p>

<p class="c0"><span class="c1">1 2 3 1 3 3 </span><span class="c5 c1 c12">5
9</span><span class="c5 c1"> </span><span class="c5 c11 c1">7</span></p>

<p class="c0"><span class="c1">2 3 1 3 3 2 </span><span class="c5 c12 c1">9
9</span><span class="c5 c1"> </span><span class="c5 c11 c1">9</span></p>

<p class="c0"><span class="c1">            </span><span
class="c5 c11 c1">8 9 6</span></p>

<h2 class="c0 c6"><a name="h.9unrpmwrlvxe"></a><span class="c5 c14">Esercizio
2</span></h2>

<p class="c0"><span>Con riferimento alla struttura SCL descritta di
seguito</span></p>

<p class="c0 c7"><span></span></p>

<p class="c0"><span class="c1">struct NodoSCL {</span></p>

<p class="c0"><span class="c1">  int info;</span></p>

<p class="c0"><span class="c1">  struct NodoSCL*next;</span></p>

<p class="c0"><span class="c1">};</span></p>

<p class="c0"><span class="c1">typedef NodoSCL* TipoSCL;</span></p>

<p class="c0 c7"><span></span></p>

<p class="c0"><span> implementare la seguente
funzione</span><span> C:</span></p>

<p class="c0 c18"><span class="c1">int rotateList(int** v, TipoSCL src, int
num);</span></p>

<p class="c0 c7 c18"><span class="c1"></span></p>

<p class="c0"><span>che dati:</span></p>
<ul class="c10 lst-kix_e1qk995u8hc6-0 start">
  <li class="c0 c2 c4"><span>un puntatore ad un array di interi </span><span
    class="c1">v</span></li>
</ul>
<ul class="c10 lst-kix_ym0w6xgs98yu-0 start">
  <li class="c0 c2 c4"><span>una lista </span><span
    class="c1">src</span><span> di lunghezza </span><span
  class="c1">l</span></li>
  <li class="c0 c2 c4"><span>un intero 0&lt;= </span><span
    class="c1">num&lt;l</span></li>
</ul>

<p class="c0"><span class="c1"><code>restituisca</code></span></p>
<ul class="c10 lst-kix_ym0w6xgs98yu-0">
  <li class="c0 c2 c4"><span>come valore di ritorno la lunghezza della lista (0
    se la lista è vuota)</span></li>
  <li class="c0 c2 c4"><span>allochi in </span><span
    class="c1">v</span><span> un array di lunghezza </span><span class="c1">l
    (impostare l'array a NULL se la list è vuota). </span><span>I valori di
    </span><span class="c1">v</span><span>, devono essere tali che</span></li>
</ul>
<ul class="c10 lst-kix_ym0w6xgs98yu-1 start">
  <li class="c0 c4 c17"><span>i primi </span><span
    class="c1">num</span><span> elementi di </span><span class="c1">v
    </span><span>siano gli ultimi </span><span class="c1">num
    </span><span>elementi di </span><span class="c1">src</span></li>
  <li class="c0 c4 c17"><span>i successivi</span><span class="c1"> l-num
    </span><span>elementi di v siano i primi </span><span
    class="c1">l-num</span><span> elementi di </span><span
    class="c1">src</span></li>
</ul>

<h4 class="c0 c9"><a name="h.i1mod4t9pma3"></a><span
class="c8 c5">Esempio</span></h4>

<p class="c0"><span>sia src la seguente sequenza</span></p>

<p class="c0"><span class="c1">1 2 3 4 5 6 7</span></p>

<p class="c0"><span>Invocando:</span></p>

<p class="c0 c2"><span class="c1">int* v;</span></p>

<p class="c0 c2"><span class="c1">int l = rotateList(&amp;v, src, 2);</span></p>

<p class="c0 c7 c2"><span class="c1"></span></p>

<p class="c0"><span>produce in </span><span class="c1">v </span><span>seguente
risultato:</span></p>

<p class="c0"><span class="c1">6 7 1 2 3 4 5</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span>e ritorna 7 (la lunghezza della lista).</span></p>

<h3></h3>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0 c7"><span><span class="c5 c14">Esercizio 3</span></span></p>

<h4></h4>

<p class="c0"><span>Sia data una lista i cui elementi appartengono alla
seguente struttura ListElement:</span></p>

<p class="c0 c7"><span></span></p>

<p class="c0"></p>

<p class="c0"><span class="c1">struct NodoSCL {</span></p>

<p class="c0"><span class="c1">  int info;</span></p>

<p class="c0"><span class="c1">  struct NodoSCL*next;</span></p>

<p class="c0"><span class="c1">};</span></p>

<p><span><code>typedef NodoSCL* TipoSCL;</code></span></p>

<p class="c0 c7"><span></span></p>

<p class="c0"><span>Si realizzi la funzione <strong>ricorsiva
</strong>C:<strong></strong></span></p>

<p class="c0"><span class="c1">TipoSCL minElements(TipoSCL l1, TipoSCL
l2)</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span>che date due liste </span><span
class="c3">l1</span><span> e </span><span class="c3">l2</span><span>,
</span><span class="c16">aventi la stessa lunghezza</span><span> restituisca
una nuova lista. Tale lista deve avere la lunghezza di l1 (e quindi anche di
l2). L'elemento in posizione </span><span class="c3">i</span><span> della
lista ritornata deve avere il valore minimo tra l'elemento in posizione
</span><span class="c3">i</span><span> di </span><span
class="c1">l1</span><span> e l'elemento in posizione </span><span
class="c3">i</span><span> di </span><span
class="c1">l2</span><span>.</span></p>

<p>Si supponga di avere in input sempre liste di egual lunghezza.</p>

<h4 class="c0 c9"><a name="h.wbew4jz0czzk" id="h.wbew4jz0czzk"></a><span
class="c5 c8">Esempio</span></h4>

<p class="c0"><span>sia l1 la seguente sequenza</span></p>

<p class="c0"><span class="c1">1 1 3 4 5 6 7</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span>sia l2 la seguente sequenza</span></p>

<p class="c0"><span class="c1">7 2 3 9 1 1 2</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span>Invocando:</span></p>

<p class="c0"><span class="c1">TipoSCL result = minElements(l1, l2);</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span>produce in result il seguente risultato:</span></p>

<p class="c0"><span class="c1">1 1 3 4 1 1 2</span></p>

<p class="c0 c7"><span class="c1"></span></p>

<p class="c0"><span>Se le liste sono vuote, la funzione ritorna </span><span
class="c1">null</span><span>.</span></p>
</body>
</html>
