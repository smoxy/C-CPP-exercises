<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=windows-1252" http-equiv="content-type">
    <title>Esame di Tecniche di Programmazione del 10/04/2017</title>
    <style>
      img {
      margin: 15px;
      }
      
      .maxwidth {
      font-family: Verdana, Geneva, sans-serif;
      max-width: 1000px;
      margin: auto;
      position: absolute;
      left: 50%;
      margin-right: -50%;
      transform: translate(-50%);
      }
      
      hr {
      border: 1px solid;
      color: gray;
      }
    </style>
  </head>

  <body>
    <div class="maxwidth">
      
      <h1>Esame di Tecniche di Programmazione del 10/04/2017</h1>
      <hr>

      <h3>Istruzioni per lo svolgimento della prova:</h3>
      <ul>
	<li>Inserire i propri dati personali (<strong>matricola, nome e
	    cognome</strong>) nel file studente.txt.</li>
	<li>All'esercizio i &egrave; associata la
	  directory <code>esercizio{i}</code>, contenente i file necessari
	  allo svolgimento dell'esercizio. Ciascun esercizio deve essere
	  svolto modificando esclusivamente il file <code>esercizio{i}.h
	  </code> (se necessario) ed <code>esercizio{i}.c</code> presenti
	  nella directory corrispondente. Nessun file per qualsiasi motivo
	  deve essere spostato dalla directory in cui si trova. Nessun altro
	  file deve essere modificato. Non devono essere creati ulteriori
	  file.</li>
	<li>Il file contenente il programma principale di ciascun esercizio
	  &egrave; <code> test_esercizio{i}.c</code>. Tale file deve essere
	  compilato usando il <code> Makefile</code> fornito nella directory,
	  ed il corrispondente eseguibile (<code> test_esercizio{i}</code>)
	  lanciato per eseguire i test di correttezza e conoscerne l'esito. Il
	  file <code>test_esercizio{i}.c</code> non deve essere modificato per
	  alcun motivo.</li>
	<li>Alla fine del tempo concesso per svolgere l' esame o, avvisare il tutor
	  per effettuare la consegna.</li>
	<li>Per eventuali problemi o dubbi, chiedere al docente.</li>
      </ul>
      <hr>

      <p><br></p>

      <h2>Esercizio 1</h2>
      <p>Sia data la seguente struttura <code>Mat:</code></p>
      <p><code>
	  typedef struct Mat {<br>
	  &nbsp;&nbsp;int cols; // numero di colonne<br>
	  &nbsp;&nbsp;int rows; // numero di righe<br>
	  &nbsp;&nbsp;float** row_ptrs; // puntatori alle righe<br>
	  } Mat;
      </code></p>
      <p>Implementare la seguente funzione C:</p>
      <p><code>void matrix_compute_neighboor_sub(Mat* dest, Mat*
	  src);</code></p>
      <p>che dati in input:
	<ul>
	  <li>un puntatore ad una matrice <code>dest</code>, preallocata ed
	    avente le stesse dimensioni di <code>src</code></li>
	  <li>un puntatore ad una matrice <code>src</code></li>
	</ul>
	inserisca in ogni cella <code>[r, c]</code> della matrice <code>dest</code>,
	la differenza tra la cella <code>[r, c]</code> e tutti i suoi
	otto vicini.</p>
      <p>Gli otto vicini della cella <code>[r,c]</code> sono le celle
	<code>[r-1, c-1]</code>, <code>[r-1, c]</code>, <code>[r-1,
	  c+1]</code>, <code>[r, c-1]</code>, <code>[r,
	  c+1]</code>, <code>[r+1, c-1]</code>, <code>[r+1, c]</code>
	e <code>[r+1, c+1]</code>.  Se una cella si trova sul bordo, i
	"vicini" di una cella non includono elementi fuori della
	matrice.</p>
</p>

<h3>Esempio</h3>
<p>Data una struttura <code>Mat src</code> contenente la seguente
  matrice <code>5x5</code>:</p>
<pre>
  3  4  3  3  4  2 
  4  4  1  0 -3  3 
  3 -4  1 -2  1 -2 	
</pre>
<p>e data una struttura <code>Mat dest</code> contenente una matrice
  della stessa dimensione di <code>src</code>, richiamando la seguente
  linea di codice:</p>
<p><code>matrix_compute_neighboor_sub(&amp;dest, &amp;src);</code></p>
<p>si ottiene il seguente effetto su <code>dest</code>:</p>
<pre>
  -9 -11 -9 -2  -1 -2 
  -6 -11 -8 -8 -12  1 
  -1 -17  2 -2   5 -3 
</pre>
<hr>

<p><br></p>

<h2>Esercizio 2</h2>
<p>Sia data una lista i cui elementi appartengono alla seguente struttura <code>NodoSCL</code>:<br>
  <br>
  <code>struct ListNode {<br>
    &nbsp; int value;<br>
    &nbsp; struct NodoSCL* next;<br>
    };</code></p>
<p>Si realizzi la funzione</p>
<ul>
  <li><code>ListNode* fetch_elements(ListNode* element_positions, int* v, int v_size);</code></li>
</ul>
<p>che dati in input:
  <ul>
    <li>una lista di interi <code>element_positions</code></li>
    <li>un puntatore ad un array di interi <code>v</code></li>
    <li>un intero <code>v_size</code> rappresentante la lunghezza dell'array <code>v</code></li>
  </ul>
  restituisca una nuova lista della stessa dimensione della
  lista <code>element_positions</code>. L'elemento in
  posizione <code>i</code> di tale lista deve avere
  valore <code>v[src[i]->value]</code>, dove la
  notazione <code>src[i]->value</code> indica il valore
  dell'elemento in posizione <code>i</code> della lista di input
  passata come parametro.

  <h3>Esempio</h3>
<p>Dato il seguente vettore di input <code>v</code>
<p><code>2 -3 2 -1 4 3</code><br><br>
  e data la seguente lista di posizioni <code>element_positions</code> 
<p><code>1 -&gt; 5 -&gt; 0 -&gt; 3 -&gt; 0 -&gt; 3</code><br><br>
  l' esecuzione della seguente istruzione<br><br>
  <code>ListNode* l = fetch_elements(element_positions, v, 6);</code><br><br>
  genera e restituisce la seguente lista <code>l</code>:<br><br>
  <code>-3 -&gt; 3 -&gt; 2 -&gt; -1 -&gt; 2 -&gt; -1</code><br></p>
<hr>

<p><br></p>


<h2>Esercizio 3</h2>

<p>Le matrici sparse sono particolari matrici in cui molti degli elementi sono
uguali a zero. In questo esercizio gli elementi diversi da zero di una matrice
sparsa sono rappresentati con la struttura <code>SparseMatrixElement</code>
contenente gli indici di riga e colonna (<code>row</code> e <code>col</code>)
dell' elemento, il suo valore <code>value</code>, ed il campo <code>next</code>
che punta al prossimo elemento della matrice diverso da zero. Note le
dimensioni di una matrice sparsa, la si pu√≤ rappresentare come una lista di
strutture <code>SparseMatrixElement</code>:</p>

<p></p>

<p><code>struct SparseMatrixElement {</code></p>

<p><code> int row;</code></p>

<p><code> int col;</code></p>

<p><code> float value;</code></p>

<p><code> SparseMatrixElement* next; </code></p>

<p><code>};</code></p>

<p><code>typedef struct SparseMatrixElement SparseMatrixElement;</code></p>

<p><code>typedef SparseMatrixElement* SparseMatrix;</code></p>

<p></p>


<p>Implementare la seguente funzione <strong>ricorsiva</strong> C:</p>

<p></p>

<p><code>int sparse_matrix_contains_element(SparseMatrix sparse_mat, float
    value);</code><br>
</p>

<p></p>

<p>che data una matrice sparsa in input <code>sparse_mat</code> (lista di
  strutture <code>SparseMatrixElement</code>)  e un valore di ricerca
  <code>value</code>, restituisca <code>1</code> se <code>sparse_mat</code>
  contiene un elemento di valore <code>value</code>, <code>0</code>
  altrimenti.</p>

<h3>Esempio</h3>

<p><span style="font-family: monospace;">parse_mat = [row: 0, col: 0, value:
    1.0] --&gt; [row: 0, col: 2, value: 2.5] --&gt; [row: 1, col: 2, value: 5.0]
    --&gt; [row: 2, col: 2, value: 3.0] --&gt; NULL</span></p>

<p><code>value = 2.5</code></p>

<p>La funzione restituisce <code>1</code>.</p>

<p></p>

<h1><a title="Download Esame" href="20170410.tar.gz">Download Esame</a></h1>

</div>
</body>
</html>
